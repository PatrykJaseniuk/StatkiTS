# 2 â›µ Model Statku

## 2.0
Statek bÄ™dzie zbudowany z obiektÃ³w klasy `ObiektFizyczny`, ktÃ³re bÄ™dÄ… powiÄ…zana ze sobÄ… wiÄ…zaniami. 

Czy powinienem wiÄ…zania uczyniÄ‡ osobnÄ… klasÄ… czy umieÅ›ciÄ‡ je w klasie `ObiektFizyczny`?

WczeÅ›niej dodam klasÄ™ `Vektor` do przechowywania wektorÃ³w.

Wykorzystam klasÄ™ wektorÃ³w z biblioteki Tree.js

DodaÅ‚em siÅ‚Ä™ oporu ktÃ³ra zaleÅ¼y od kwadratu prÄ™dkoÅ›ci. Model fizyki nie jest stabilny, gdy zadziaÅ‚am zbyt duÅ¼Ä… siÅ‚Ä… obiekt przesuwa siÄ™ gwaÅ‚townie gdzieÅ› daleko.

## 2.1
Naprawa modelu fizyki

Kiedy wprowadziÅ‚em siÅ‚Ä™ oporu ktÃ³ra zaleÅ¼y od kwadratu prÄ™dkoÅ›ci to model fizyki przestaÅ‚ byÄ‡ stabilny.
Jest to spowodowane tym Å¼e zmiana prÄ™dkoÅ›ci w przeciwnÄ… stronÄ™ jest ponad dwukrotnie wiÄ™ksza niÅ¼ prÄ™dkoÅ›Ä‡ aktualna co powodujÄ™ Å¼e obiekt zaczyna przyspieszaÄ‡ w nieskoÅ„czonoÅ›Ä‡. JeÅ¼eli zmiana prÄ™dkoÅ›ci w przeciwnÄ… stronÄ™ bÄ™dzie mniejsza niÅ¼ dwukrotnie prÄ™dkoÅ›Ä‡ aktualna, ale wiÄ™ksza niÅ¼ ta prÄ™dkoÅ›Ä‡ to obiekt zacznie drgaÄ‡, ale siÄ™ ustabilizuje. Drganie obiektu teÅ¼ jest problemem poniewaÅ¼ takie rzeczy nie istniejÄ… w rzeczywistoÅ›ci.
```TS
 let przyspieszeniePomocnicze = this.przyspieszenie.clone();

        // przyspieszenie w przeciwnym kierunku niÅ¼ prÄ™dkoÅ›Ä‡ nie mozÄ™ byÄ‡ wiÄ™ksze od prÄ™dkoÅ›ci, bo obiekt fizyczny zaczyna drgaÄ‡, a jeÅ¼eli jest dwa razy wiÄ™ksze to obiekt przesuwa siÄ™ w nieskoÅ„czonoÅ›Ä‡
        if (Math.sign(this.przyspieszenie.x) != Math.sign(this.predkosc.x) && this.predkosc.x != 0) {
            if (Math.abs(this.przyspieszenie.x) > Math.abs(this.predkosc.x)) {
                this.predkosc.x = 0;
                przyspieszeniePomocnicze.x = 0;
            }
        }
        if (Math.sign(this.przyspieszenie.y) != Math.sign(this.predkosc.y) && this.predkosc.y != 0) {
            if (Math.abs(this.przyspieszenie.y) > Math.abs(this.predkosc.y)) {
                this.predkosc.y = 0;
                przyspieszeniePomocnicze.y = 0;
            }
        }
        this.predkosc.add(przyspieszeniePomocnicze);
```
## 2.2 ÅÄ…czenie obiektÃ³w fizycznych ze sobÄ…
`Statek` bÄ™dzie zbudowany z obiektÃ³w klasy `ObiektFizyczny`, ktÃ³re bÄ™dÄ… powiÄ…zana ze sobÄ… `wiÄ…zaniami`.

Pixi.js nie posiada klasy Vector z podstawowymi metodami np odlegÅ‚oÅ›Ä‡ miedzy punktami. Dlatego zastanawiam siÄ™ nad migracjÄ… do biblioteki Three.js. 

kolejne aplikacje bÄ™dÄ… wykonane z wykorzystaniem biblioteki Three.js. W tym celu modyfikujÄ™ [layout](../components/layout.tsx)

ZrobiÅ‚em helloWord z wykorzystaniem biblioteki Three.js

Teraz picking obiektÃ³w na scenie

Teraz draging obiektÃ³w na scenie

## 2.3 PoÅ‚Ä…czenie obiektÃ³w w statek   

[statek](../appsThree/Statek.ts)

StworzyÅ‚em klasÄ™ statek, ktÃ³ra skÅ‚ada siÄ™ z kadÅ‚uba i dwÃ³ch Å¼agli

## 2.4 Rozbudowa modelu fizyki o ruch obrotowy

Dynamika ruchu obrotowego: 
[[Ruchu Obrotowy]]

Oddaje atrybuty od  [ObietkFizyczny](../appsThree/RuchObrotowy/Obiekty/ObiektFizyczny.ts):

```TS
// ruch obrotowy
private predkoscKatowa: number = 0.01;
private przyspieszenieKatowe: number = 0;
private silaKatowa: number = 1;
private momentBezwladnosci: number = 1;
```
I dodaje metody aby wyznaczaÅ‚y wartoÅ›ci tych atrybutÃ³w dla kolejnych iteracji.


ModyfikujÄ™ metodÄ™ `wyznaczSily` z klasy [Wizanie](../appsThree/RuchObrotowy/Obiekty/Wiazanie.ts) aby przy wyzanaczaniu siÅ‚ uwzglÄ™dniaÅ‚a obrot obiektÃ³w.

```TS
let punktPrzyczepienia1 = this.wezel1.punktPrzyczepienia.clone()
        // obroc wezel1 o kat obrotu obiektu1
        punktPrzyczepienia1.applyAxisAngle(new Vector3(0, 0, 1), this.wezel1.obiekt.rotation.z);

        let punktPrzyczepienia2 = this.wezel2.punktPrzyczepienia.clone()
        // obroc wezel2 o kat obrotu obiektu2
        punktPrzyczepienia2.applyAxisAngle(new Vector3(0, 0, 1), this.wezel2.obiekt.rotation.z);
```

Teraz wyznaczÄ™ momenty bezwÅ‚adnoÅ›ci we wÅ‚aÅ›ciwy sposÃ³b tzn za pomocÄ… funkcji masy i ksztaÅ‚tu obiektu.
https://en.wikipedia.org/wiki/List_of_moments_of_inertia
BezwÅ‚adnoÅ›Ä‡ wyzanczÄ™ ze wzoru 
![{\displaystyle I_{c}={\frac {1}{12}}m\left(h^{2}+w^{2}\right)\,\!}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e82e609b07a1d3c867887160c16b73c9323f7be5)Â Â 
Model dziaÅ‚a Åºle. 

SprÃ³buje inaczej.
Obiekt ktÃ³ry bÄ™dzie siÄ™ obracaÅ‚ bÄ™dzie zrobiony z punktÃ³w, ktÃ³re wykonujÄ… tylko ruch postÄ™powy i sÄ… poÅ‚Ä…czone se sobÄ… oddziaÅ‚ywaniami sprÄ™Å¼ystymi. Obiekt bÄ™dzie siÄ™ obracaÅ‚ kiedy punkty bÄ™dÄ… siÄ™ przemieszczaÄ‡ w rÃ³Å¼nej szybkoÅ›ci. Pozycja obrazka reprezentujÄ…cego obiekt bÄ™dzie wyliczana na podstawia pozycji punktÃ³w. Minimalna iloÅ›Ä‡ punktÃ³w aby to dziaÅ‚aÅ‚o to 3. 

Jakie mogÄ… byÄ‡ maksymalne zmiany atrybutÃ³w aby system byÅ‚ stabilny?
JeÅ¼eli dziaÅ‚a zbyt duÅ¼a sia -> obiekt zaczyna zbyt bardzo przyspieszaÄ‡-> duÅ¼a szybkoÅ›Ä‡-> duÅ¼a zmiana poÅ‚oÅ¼enia -> duÅ¼a zmiana siÅ‚ ktÃ³re dziaÅ‚ajÄ… na obiekty -> model nie jest stabilny. 
Jak wyznaczyÄ‡ granicÄ™? 
MoÅ¼e skorzystam z [[zasada zachowania energii]], albo [[zasada zachowania pÄ™du]]

SprÃ³bujÄ™ tak:
Do sytemu wprowadzÄ™ dt(powinienem to zrobiÄ‡ od razu).
I tak: mam dwa Å›wiaty: 
+ symulacja 
+ rzeczywisty
wiÄ™c mam teÅ¼ dwie dt:
+ `dts` - zmiana czasu w symulacji 
+ `dtr` - zmiana czasu w Å›wiecie rzeczywistym (czs ktÃ³ry upÅ‚ynÄ…Å‚ od poprzednio narysowanej klatki)
+ 

Czas ktÃ³ry upÅ‚ynÄ…Å‚ w symulacji jest rÃ³wny sumie wszystkich dts przesÅ‚anych do symulacji.
Czas w symulacji powinien byÄ‡ rÃ³wny czasowi w rzeczywistoÅ›ci.

JeÅ¼eli w symulacja zacznie Å‚amaÄ‡ zasady zachowania pÄ™du oznacza to Å¼e dts jest zbyt duÅ¼e i naleÅ¼y dokonaÄ‡ wiÄ™cej zmian stanu o mniejszym dts. 

<!-- tabela -->
| 10ms | 20ms | 30ms | 40ms| 50ms|60ms|
|---|---|---|---|---|---|
| wyznaczanie nowego stanu({dts: 40ms}) |  |  | rysowanie klatki| |0.06|



## Przerabiam system 

System bÄ™dzie siÄ™ skÅ‚adaÅ‚ z dwÃ³ch elementÃ³w:
+ Stanu Å›wiata
+ Modyfikatora Å›wiata
Åšwiat jest zbudowany z elementÃ³w, ktÃ³re sÄ… ze sobÄ… powiÄ…zane, tworzÄ…c rÃ³Å¼ne struktury. Element kaÅ¼dej z klas w momencie powstania zapisuje siÄ™ do tablicy modyfikatora elementÃ³w tej klasy. KaÅ¼da klasa elementÃ³w posiada swÃ³j modyfikator, ktÃ³ry modyfikuje wszystkie elementy (obiekty) danej klasy.
Wszystkie modyfikatory elementÃ³w sÄ… wywoÅ‚ywane w odpowiedniej kolejnoÅ›ci (nawet asynchronicznie, a moÅ¼e nawet rÃ³wnolegle) w modyfikatorze Å›wiata. 

NaleÅ¼y zachowaÄ‡ szczegÃ³lnÄ… ostroÅ¼noÅ›Ä‡ ze zmiennymi globalnymi (updatery).

Aby uruchomiÄ‡ testy obiektÃ³w, ktÃ³re korzystajÄ… ze zmiennych globalnych przeglÄ…darki, naleÅ¼y zasymulowaÄ‡ takie Å›rodowisko. Do tego celu uÅ¼ywam moÅ¼liwoÅ›ci konfiguracji `jest` :
+ pobieram odpowiednie Å›rodowisko testowe: ```
``` bash 
npm install jest-environment-jsdom
```
+ modyfikuje plik `jest.config.js`
``` js
testEnvironment: 'jsdom',
```



## StabilnoÅ›Ä‡ modelu dynamiki

Model jest stabilny, jeÅ¼eli postÄ™puje zgodne z zasadÄ… zachowania pÄ™du 
```ts
test('momentum conservation', () => {
let forces: Force[] = [];
forces.push(force1);
forces.push(force2);
let momentum0 = calculateMomentum(forces);
for (let i = 0; i < 10000; i++) {
dynamicModelUpdate();
}
let momentum1 = calculateMomentum(forces);
expect(momentum0.distanceTo(momentum1) < 0.00001 * momentum0.length()).toBeTruthy();
});  
```

Wyznaczenie poÅ‚oÅ¼enia obiektÃ³w w chwili `t` wymaga scaÅ‚kowania rÃ³wnania ruchu Newtona

Do tego celu uÅ¼yjÄ™ integratora Vertela: [[https://en.wikipedia.org/wiki/Verlet_integration]]

Algorytm integratora Vertela z przykÅ‚adu na wiki nie dziaÅ‚a, jak powinien, wiÄ™c pozostajÄ™ przy pierwotnej wersji.

PÄ™d jest staÅ‚y, jeÅ¼eli `dt` jest dostatecznie maÅ‚e. Istnieje takie `dtMax` poniÅ¼ej, ktÃ³rego system jest stabilny.  Jak podaje Wikipedia `dtMax` jest zwiÄ…zane z najwiÄ™kszÄ… czÄ™stoÅ›ciÄ… drgania ktÃ³regokolwiek molekuÅ‚u systemu. [[https://en.wikipedia.org/wiki/Energy_drift]]

```
dtMax = 2^(1/2)/omega
```
![{\displaystyle \Delta t<{\frac {\sqrt {2}}{\omega }}\approx 0.225p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2ce85b09695b0dbc73db5971451e712ed4f9f114)

Omega jest staÅ‚a, jeÅ¼eli oddziaÅ‚ywania siÄ™ nie zmieniajÄ…, to znaczy nie powstajÄ… i nie znikajÄ… nowe obiekty klasy [Interaction](Interaction.ts). Omega jest rÃ³wna 
```
omega = (k/m)^(1/2)
```
gdzie:
+ `k` - wspÃ³Å‚czynnik sprÄ™Å¼ystoÅ›ci
+ `m` - masa

Dla czÄ…stek, ktÃ³re podlegajÄ… wielu oddziaÅ‚ywaniom, zsumujÄ™ wspÃ³Å‚czynnik sprÄ™Å¼ystoÅ›ci, tak jak by sprÄ™Å¼yny byÅ‚y poÅ‚Ä…czone rÃ³wnolegle.

Teraz znajdujÄ™ najwiÄ™kszÄ… omegÄ™ i na jej podstawie wyznaczam `dtMax` poniÅ¼ej ktÃ³rej system jest stabilny. 
Ciekawe ğŸ¤”, Å¼e to dziaÅ‚a:

```ts
test('momentum conservation for for wsp = 2^(1/2)', () => {
        // molecular model is stable (conservation of momentum) if dt< wsp /omegaMax
        // where omegaMax is the highest oscilation frequency of the molecul in the system 
        // according to Wikipedia wsp should be 2^(1/2)
        dynamicElement1.velocity = new Vector2(10, 0);
        dynamicElement2.mass = 10000000;
        
        for (let i = 1; i < 1000; i++) {
            interaction.springRate = Math.random() * 1000;
            dynamicElement1.mass = Math.random() * 1000;
            dynamicElement2.mass = Math.random() * 1000;
            dynamicElement1.velocity = new Vector2(10, Math.random() * 1000);
            let maximumDt = calculatemaximumDt(interaction.springRate, dynamicElement1.mass, dynamicElement2.mass);
            maximumDt *= 1;
            let momentum0 = dynamicElement1.getMomentum().add(dynamicElement2.getMomentum());
            for (let i = 0; i < 10000; i++) {
                interaction.update();
                dynamicElementUpdater.update(maximumDt);
            }
            let momentum1 = dynamicElement1.getMomentum().add(dynamicElement2.getMomentum());
            expect(momentum0.distanceTo(momentum1) <= 0.01 * momentum0.length()).toBeTruthy();
        }
    });
```
JeÅ¼eli `maximumDt` pomnoÅ¼Ä™, chociaÅ¼ przez `1.1` to system przestaje byÄ‡ stabilny. ğŸ‘

