# 2 ⛵ Model Statku

## 2.0
Statek będzie zbudowany z obiektów klasy `ObiektFizyczny`, które będą powiązana ze sobą wiązaniami. 

Czy powinienem wiązania uczynić osobną klasą czy umieścić je w klasie `ObiektFizyczny`?

Wcześniej dodam klasę `Vektor` do przechowywania wektorów.

Wykorzystam klasę wektorów z biblioteki Tree.js

Dodałem siłę oporu która zależy od kwadratu prędkości. Model fizyki nie jest stabilny, gdy zadziałam zbyt dużą siłą obiekt przesuwa się gwałtownie gdzieś daleko.

## 2.1
Naprawa modelu fizyki

Kiedy wprowadziłem siłę oporu która zależy od kwadratu prędkości to model fizyki przestał być stabilny.
Jest to spowodowane tym że zmiana prędkości w przeciwną stronę jest ponad dwukrotnie większa niż prędkość aktualna co powoduję że obiekt zaczyna przyspieszać w nieskończoność. Jeżeli zmiana prędkości w przeciwną stronę będzie mniejsza niż dwukrotnie prędkość aktualna, ale większa niż ta prędkość to obiekt zacznie drgać, ale się ustabilizuje. Drganie obiektu też jest problemem ponieważ takie rzeczy nie istnieją w rzeczywistości.
```TS
 let przyspieszeniePomocnicze = this.przyspieszenie.clone();

        // przyspieszenie w przeciwnym kierunku niż prędkość nie mozę być większe od prędkości, bo obiekt fizyczny zaczyna drgać, a jeżeli jest dwa razy większe to obiekt przesuwa się w nieskończoność
        if (Math.sign(this.przyspieszenie.x) != Math.sign(this.predkosc.x) && this.predkosc.x != 0) {
            if (Math.abs(this.przyspieszenie.x) > Math.abs(this.predkosc.x)) {
                this.predkosc.x = 0;
                przyspieszeniePomocnicze.x = 0;
            }
        }
        if (Math.sign(this.przyspieszenie.y) != Math.sign(this.predkosc.y) && this.predkosc.y != 0) {
            if (Math.abs(this.przyspieszenie.y) > Math.abs(this.predkosc.y)) {
                this.predkosc.y = 0;
                przyspieszeniePomocnicze.y = 0;
            }
        }
        this.predkosc.add(przyspieszeniePomocnicze);
```
## 2.2 Łączenie obiektów fizycznych ze sobą
`Statek` będzie zbudowany z obiektów klasy `ObiektFizyczny`, które będą powiązana ze sobą `wiązaniami`.

Pixi.js nie posiada klasy Vector z podstawowymi metodami np odległość miedzy punktami. Dlatego zastanawiam się nad migracją do biblioteki Three.js. 

kolejne aplikacje będą wykonane z wykorzystaniem biblioteki Three.js. W tym celu modyfikuję [layout](../components/layout.tsx)

Zrobiłem helloWord z wykorzystaniem biblioteki Three.js

Teraz picking obiektów na scenie

Teraz draging obiektów na scenie

## 2.3 Połączenie obiektów w statek   

[statek](../appsThree/Statek.ts)

Stworzyłem klasę statek, która składa się z kadłuba i dwóch żagli

## 2.4 Rozbudowa modelu fizyki o ruch obrotowy

Dynamika ruchu obrotowego: 
[[Ruchu Obrotowy]]

Oddaje atrybuty od  [ObietkFizyczny](../appsThree/RuchObrotowy/Obiekty/ObiektFizyczny.ts):

```TS
// ruch obrotowy
private predkoscKatowa: number = 0.01;
private przyspieszenieKatowe: number = 0;
private silaKatowa: number = 1;
private momentBezwladnosci: number = 1;
```
I dodaje metody aby wyznaczały wartości tych atrybutów dla kolejnych iteracji.


Modyfikuję metodę `wyznaczSily` z klasy [Wizanie](../appsThree/RuchObrotowy/Obiekty/Wiazanie.ts) aby przy wyzanaczaniu sił uwzględniała obrot obiektów.

```TS
let punktPrzyczepienia1 = this.wezel1.punktPrzyczepienia.clone()
        // obroc wezel1 o kat obrotu obiektu1
        punktPrzyczepienia1.applyAxisAngle(new Vector3(0, 0, 1), this.wezel1.obiekt.rotation.z);

        let punktPrzyczepienia2 = this.wezel2.punktPrzyczepienia.clone()
        // obroc wezel2 o kat obrotu obiektu2
        punktPrzyczepienia2.applyAxisAngle(new Vector3(0, 0, 1), this.wezel2.obiekt.rotation.z);
```

Teraz wyznaczę momenty bezwładności we właściwy sposób tzn za pomocą funkcji masy i kształtu obiektu.
https://en.wikipedia.org/wiki/List_of_moments_of_inertia
Bezwładność wyzanczę ze wzoru 
![{\displaystyle I_{c}={\frac {1}{12}}m\left(h^{2}+w^{2}\right)\,\!}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e82e609b07a1d3c867887160c16b73c9323f7be5)  
Model działa źle. 

Spróbuje inaczej.
Obiekt który będzie się obracał będzie zrobiony z punktów, które wykonują tylko ruch postępowy i są połączone se sobą oddziaływaniami sprężystymi. Obiekt będzie się obracał kiedy punkty będą się przemieszczać w różnej szybkości. Pozycja obrazka reprezentującego obiekt będzie wyliczana na podstawia pozycji punktów. Minimalna ilość punktów aby to działało to 3. 

Jakie mogą być maksymalne zmiany atrybutów aby system był stabilny?
Jeżeli działa zbyt duża sia -> obiekt zaczyna zbyt bardzo przyspieszać-> duża szybkość-> duża zmiana położenia -> duża zmiana sił które działają na obiekty -> model nie jest stabilny. 
Jak wyznaczyć granicę? 
Może skorzystam z [[zasada zachowania energii]], albo [[zasada zachowania pędu]]

Spróbuję tak:
Do sytemu wprowadzę dt(powinienem to zrobić od razu).
I tak: mam dwa światy: 
+ symulacja 
+ rzeczywisty
więc mam też dwie dt:
+ `dts` - zmiana czasu w symulacji 
+ `dtr` - zmiana czasu w świecie rzeczywistym (czs który upłynął od poprzednio narysowanej klatki)
+ 

Czas który upłynął w symulacji jest równy sumie wszystkich dts przesłanych do symulacji.
Czas w symulacji powinien być równy czasowi w rzeczywistości.

Jeżeli w symulacja zacznie łamać zasady zachowania pędu oznacza to że dts jest zbyt duże i należy dokonać więcej zmian stanu o mniejszym dts. 

<!-- tabela -->
| 10ms | 20ms | 30ms | 40ms| 50ms|60ms|
|---|---|---|---|---|---|
| wyznaczanie nowego stanu({dts: 40ms}) |  |  | rysowanie klatki| |0.06|





