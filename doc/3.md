## Przerabiam system 

System będzie się składał z dwóch elementów:
+ Stanu świata
+ Modyfikatora świata
Świat jest zbudowany z elementów, które są ze sobą powiązane, tworząc różne struktury. Element każdej z klas w momencie powstania zapisuje się do tablicy modyfikatora elementów tej klasy. Każda klasa elementów posiada swój modyfikator, który modyfikuje wszystkie elementy (obiekty) danej klasy.
Wszystkie modyfikatory elementów są wywoływane w odpowiedniej kolejności (nawet asynchronicznie, a może nawet równolegle) w modyfikatorze świata. 

Należy zachować szczególną ostrożność ze zmiennymi globalnymi (updatery).

Aby uruchomić testy obiektów, które korzystają ze zmiennych globalnych przeglądarki, należy zasymulować takie środowisko. Do tego celu używam możliwości konfiguracji `jest` :
+ pobieram odpowiednie środowisko testowe: ```
``` bash 
npm install jest-environment-jsdom
```
+ modyfikuje plik `jest.config.js`
``` js
testEnvironment: 'jsdom',
```



## Stabilność modelu dynamiki

Model jest stabilny, jeżeli postępuje zgodne z zasadą zachowania pędu 
```ts
test('momentum conservation', () => {
let forces: Force[] = [];
forces.push(force1);
forces.push(force2);
let momentum0 = calculateMomentum(forces);
for (let i = 0; i < 10000; i++) {
dynamicModelUpdate();
}
let momentum1 = calculateMomentum(forces);
expect(momentum0.distanceTo(momentum1) < 0.00001 * momentum0.length()).toBeTruthy();
});  
```

Wyznaczenie położenia obiektów w chwili `t` wymaga scałkowania równania ruchu Newtona

Do tego celu użyję integratora Vertela: [[https://en.wikipedia.org/wiki/Verlet_integration]]

Algorytm integratora Vertela z przykładu na wiki nie działa, jak powinien, więc pozostaję przy pierwotnej wersji.

Pęd jest stały, jeżeli `dt` jest dostatecznie małe. Istnieje takie `dtMax` poniżej, którego system jest stabilny.  Jak podaje Wikipedia `dtMax` jest związane z największą częstością drgania któregokolwiek molekułu systemu. [[https://en.wikipedia.org/wiki/Energy_drift]]

```
dtMax = 2^(1/2)/omega
```
![{\displaystyle \Delta t<{\frac {\sqrt {2}}{\omega }}\approx 0.225p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2ce85b09695b0dbc73db5971451e712ed4f9f114)

Omega jest stała, jeżeli oddziaływania się nie zmieniają, to znaczy nie powstają i nie znikają nowe obiekty klasy [Interaction](Interaction.ts). Omega jest równa 
```
omega = (k/m)^(1/2)
```
gdzie:
+ `k` - współczynnik sprężystości
+ `m` - masa

Dla cząstek, które podlegają wielu oddziaływaniom, zsumuję współczynnik sprężystości, tak jak by sprężyny były połączone równolegle.

Teraz znajduję największą omegę i na jej podstawie wyznaczam `dtMax` poniżej której system jest stabilny. 
Ciekawe 🤔, że to działa:

```ts
test('momentum conservation for for wsp = 2^(1/2)', () => {
        // molecular model is stable (conservation of momentum) if dt< wsp /omegaMax
        // where omegaMax is the highest oscilation frequency of the molecul in the system 
        // according to Wikipedia wsp should be 2^(1/2)
        dynamicElement1.velocity = new Vector2(10, 0);
        dynamicElement2.mass = 10000000;
        
        for (let i = 1; i < 1000; i++) {
            interaction.springRate = Math.random() * 1000;
            dynamicElement1.mass = Math.random() * 1000;
            dynamicElement2.mass = Math.random() * 1000;
            dynamicElement1.velocity = new Vector2(10, Math.random() * 1000);
            let maximumDt = calculatemaximumDt(interaction.springRate, dynamicElement1.mass, dynamicElement2.mass);
            maximumDt *= 1;
            let momentum0 = dynamicElement1.getMomentum().add(dynamicElement2.getMomentum());
            for (let i = 0; i < 10000; i++) {
                interaction.update();
                dynamicElementUpdater.update(maximumDt);
            }
            let momentum1 = dynamicElement1.getMomentum().add(dynamicElement2.getMomentum());
            expect(momentum0.distanceTo(momentum1) <= 0.01 * momentum0.length()).toBeTruthy();
        }
    });
```
Jeżeli `maximumDt` pomnożę, chociaż przez `1.1` to system przestaje być stabilny. 👏